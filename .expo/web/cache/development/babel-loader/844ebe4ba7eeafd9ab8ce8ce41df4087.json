{"ast":null,"code":"import userSchema from \"./userSchema\";\nimport textSchema from \"./textSchema\";\nimport optionsSchema from \"./optionsSchema\";\nimport customSchema from \"./customSchema\";\nimport updateSchema from \"./updateSchema\";\nvar schema = {\n  parse: function parse(step) {\n    var parser = [];\n\n    if (step.user) {\n      parser = userSchema;\n    } else if (step.message) {\n      parser = textSchema;\n    } else if (step.options) {\n      parser = optionsSchema;\n    } else if (step.component) {\n      parser = customSchema;\n    } else if (step.update) {\n      parser = updateSchema;\n    } else {\n      throw new Error(\"The step \" + JSON.stringify(step) + \" is invalid\");\n    }\n\n    for (var i = 0, len = parser.length; i < len; i += 1) {\n      var _parser$i = parser[i],\n          key = _parser$i.key,\n          types = _parser$i.types,\n          required = _parser$i.required;\n\n      if (!step[key] && required) {\n        throw new Error(\"Key '\" + key + \"' is required in step \" + JSON.stringify(step));\n      } else if (step[key]) {\n        if (types[0] !== 'any' && types.indexOf(typeof step[key]) < 0) {\n          throw new Error(\"The type of '\" + key + \"' value must be \" + types.join(' or ') + \" instead of \" + typeof step[key]);\n        }\n      }\n    }\n\n    var keys = parser.map(function (p) {\n      return p.key;\n    });\n\n    for (var _key in step) {\n      if (keys.indexOf(_key) < 0) {\n        console.warn(\"Invalid key '\" + _key + \"' in step '\" + step.id + \"'\");\n        delete step[_key];\n      }\n    }\n\n    return step;\n  },\n  checkInvalidIds: function checkInvalidIds(steps) {\n    for (var key in steps) {\n      var step = steps[key];\n      var triggerId = steps[key].trigger;\n\n      if (typeof triggerId !== 'function') {\n        if (step.options) {\n          var triggers = step.options.filter(function (option) {\n            return typeof option.trigger !== 'function';\n          });\n          var optionsTriggerIds = triggers.map(function (option) {\n            return option.trigger;\n          });\n\n          for (var i = 0, len = optionsTriggerIds.length; i < len; i += 1) {\n            var optionTriggerId = optionsTriggerIds[i];\n\n            if (optionTriggerId && !steps[optionTriggerId]) {\n              throw new Error(\"The id '\" + optionTriggerId + \"' triggered by option \" + (i + 1) + \" in step '\" + steps[key].id + \"' does not exist\");\n            }\n          }\n        } else if (triggerId && !steps[triggerId]) {\n          throw new Error(\"The id '\" + triggerId + \"' triggered by step '\" + steps[key].id + \"' does not exist\");\n        }\n      }\n    }\n  }\n};\nexport default schema;","map":{"version":3,"sources":["/Users/DavidPapamichael/Coding/makers/week_13+/projects/hack_for_heroes/pocket_positivity_frontend/node_modules/react-native-chatbot-expo/lib/schemas/schema.js"],"names":["userSchema","textSchema","optionsSchema","customSchema","updateSchema","schema","parse","step","parser","user","message","options","component","update","Error","JSON","stringify","i","len","length","key","types","required","indexOf","join","keys","map","p","console","warn","id","checkInvalidIds","steps","triggerId","trigger","triggers","filter","option","optionsTriggerIds","optionTriggerId"],"mappings":"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","sourcesContent":["import userSchema from './userSchema';\nimport textSchema from './textSchema';\nimport optionsSchema from './optionsSchema';\nimport customSchema from './customSchema';\nimport updateSchema from './updateSchema';\n\nconst schema = {\n  parse(step) {\n    let parser = [];\n\n    if (step.user) {\n      parser = userSchema;\n    } else if (step.message) {\n      parser = textSchema;\n    } else if (step.options) {\n      parser = optionsSchema;\n    } else if (step.component) {\n      parser = customSchema;\n    } else if (step.update) {\n      parser = updateSchema;\n    } else {\n      throw new Error(`The step ${JSON.stringify(step)} is invalid`);\n    }\n\n    for (let i = 0, len = parser.length; i < len; i += 1) {\n      const { key, types, required } = parser[i];\n\n      if (!step[key] && required) {\n        throw new Error(`Key '${key}' is required in step ${JSON.stringify(step)}`);\n      } else if (step[key]) {\n        if (types[0] !== 'any' && types.indexOf(typeof step[key]) < 0) {\n          throw new Error(`The type of '${key}' value must be ${types.join(' or ')} instead of ${typeof step[key]}`);\n        }\n      }\n    }\n\n    const keys = parser.map(p => p.key);\n\n    for (const key in step) {\n      if (keys.indexOf(key) < 0) {\n        console.warn(`Invalid key '${key}' in step '${step.id}'`);\n        delete step[key];\n      }\n    }\n\n    return step;\n  },\n\n  checkInvalidIds(steps) {\n    for (const key in steps) {\n      const step = steps[key];\n      const triggerId = steps[key].trigger;\n\n      if (typeof triggerId !== 'function') {\n        if (step.options) {\n          const triggers = step.options.filter(option => typeof option.trigger !== 'function');\n          const optionsTriggerIds = triggers.map(option => option.trigger);\n\n          for (let i = 0, len = optionsTriggerIds.length; i < len; i += 1) {\n            const optionTriggerId = optionsTriggerIds[i];\n            if (optionTriggerId && !steps[optionTriggerId]) {\n              throw new Error(`The id '${optionTriggerId}' triggered by option ${i + 1} in step '${steps[key].id}' does not exist`);\n            }\n          }\n        } else if (triggerId && !steps[triggerId]) {\n          throw new Error(`The id '${triggerId}' triggered by step '${steps[key].id}' does not exist`);\n        }\n      }\n    }\n  },\n};\n\nexport default schema;\n"]},"metadata":{},"sourceType":"module"}